//IGT Development production by AlexSNAKE
//Version-1.0a - 19.05.2024

//Подключение необходимых библиотек
#include "SoftwareSerial.h" //Версия библиоткеи 3.0.0
#include "DFRobotDFPlayerMini.h" //Версия библиоткеи 1.0.6

//Параметры конфигурации PIN
const byte greenLedPin = 2; //PIN зеленого светодиода
const byte redLedPin = 3; //PIN красного светодиода
const byte buttonPin = 4; //PIN кнопки
const byte gearconPin = 5; //PIN Гиркона
const byte speakerTxPin = 10; //PIN TX разёма для DFPlayer
const byte speakerRxPin = 11; //PIN RX разёма для DFPlayer
SoftwareSerial softwareSerial(speakerTxPin, speakerRxPin); // Присвоение пинов связи с TX и RX

bool lethalMode; //Переменная переключения режима (Боевой/Сдерживание) - (True/False)
bool collarReady; //Переменая перезагрузки ошейника (Заряжен/Разряжен) - (True/False)
unsigned int time; //Переменная хранящая теккущее премя с начала отсчета таймера (0 .. 65535)
byte track; //Переменная хранящая название запрашиваемого аудиофайла (0 .. 255)
byte carma; //Переменная хранящая время для досрочного открытия ошейника (0 .. 255)
DFRobotDFPlayerMini p; //Создание обьекта класса для взаимодействия с плеером.

void setup() { //Функция инициализации системы
	softwareSerial.begin(9600); //Соединение с DFplayer по serial port
  if (!p.begin(softwareSerial)) {while(true);} //Подключение к DFplayer
  p.volume(30); //Изменние громкости динамика

  pinMode(greenLedPin, OUTPUT); //Установка режима работы PIN - зеленый светодиод
  pinMode(redLedPin, OUTPUT); //Установка режима работы PIN - красный светодиод
  pinMode(buttonPin, INPUT_PULLUP); //Установка режима работы PIN - кнопка
  pinMode(gearconPin, INPUT_PULLUP); //Установка режима работы PIN - гиркон
}

void loop() { //Главный цикл программы, запускается когда подается питание
  if (!collarOpenedState() && collarReady) { //Если ошейник закрыт и перезгружен то
    collarActivation(lethalMode); //Активировать ошейник с выбранным режимом
  }
  
  if (collarOpenedState()) {//Если ошейник открыт то
    collarReady = true; //Пезагрузка ошейника
    selectedModeIndication(); //Мигание светодиодами для индикации выбранного режима
    changeCollarMode(); //Смена режима ошейника при нажатии кнопки
  }
}

//Функция для реализации главного функционала ошейника
void collarActivation(bool monitoringMode) { //Функция принимает выбранный режим ошейника
  track = monitoringMode ? 2 : 1; //В зависимости от режима установить название трека по умолчанию
  redLedOn();//Включение красного светодиода при закрытии ошейника
  voice(7);//Воспроизведение оповещения о включении ошейника
  do { //Повторять до того пока while не равно false
    delay(1000);//задержка цикла на 1 секунду (1000 миллисекунд)
    time += 1; //Счет прошедщих секунд с закрытия ошейника
    shouldCollarDetonate(); //Првоерка ошейника на досрочное открытие
    goodBoy(); //Проверка ошейника на удержание кнопки (освобождение)
    checkTimeLeft(); //Проверка оставшегося времении и воспроизведение аудио об оставщемся времени
  } while (time <= 36000);//Пока прошедшее время меньше или равна 360000 секунд (1 час) выполнять do {}
  voice(track+4); //По завершении времени или преждевременном событии воспроизводить инструкцию(аудио)
  collarReady = false; //Требование о перезагрузке ошейника(требование открыть ошейник для повторной активации)
  time = 0; //Сборс прошедшего времени с начала таймера
  carma = 0; //Сброс времени для преждевременного освобождения
}

//Функция для проверки досрочного открытия ошейника
void shouldCollarDetonate() {
  if (collarOpenedState()) { //Если ошйник открыт то
    track = 1; //Установить название аудио - 1 - Взрыв
    voice(track); //Воспроизвести аудио - 1 - Взрыв
    time = 65535; //Установка переменной оставшегося времени на максимум, для выхода из цикла do {}
  }
}

//Функция для досрочного освобождения пленника путем зажатия кнопки на 5 секунд
void goodBoy() {
  if (buttonPressedState()) { //Если кнопка нажата, то
    carma += 1; //Прибавлять 1 к переменной досрочного освобождения
    if (carma == 5) { //Если кнопка была удержана на протяжении 5 секунд, то
      track = 2; //Установить название аудио - 2 - Освобождение
      voice(track); //Воспроизвести аудио - 2 - Освобождение
      time = 65535; //Установка переменной оставшегося времени на максимум, для выхода из цикла do {}
    }
  } else { //Если кнопка отпущена
    carma = 0; //Сбрасывать время для досрочного освбождения
  }
}

//Функция проверки оставшегося времени до конца таймера
void checkTimeLeft() {
      if (time == 600) { //Если прошло 600сек. (10мин.), то
      voice(50); //Воспроизведение аудио об 50 минутном отсчете.
    } else if (time == 1200) { //Если прошло 1200сек. (20мин.), то
      voice(40); //Воспроизведение аудио об 50 минутном отсчете.
    } else if (time == 1800) { //Если прошло 1800сек. (30мин.), то
      voice(30); //Воспроизведение аудио об 50 минутном отсчете.
    } else if (time == 2400) { //Если прошло 2400сек. (40мин.), то
      voice(20); //Воспроизведение аудио об 50 минутном отсчете.
    } else if (time == 3000) { //Если прошло 3000сек. (50мин.), то
      voice(10); //Воспроизведение аудио об 50 минутном отсчете.
    } else if (time == 3600) { //Если прошло 3600сек. (60мин.), то
      voice(track); //Воспроизведение аудио об освобождении или детонации, зависит от режима
    }
}

//Функция отображения светодиодами выбранного режима ошейника
void selectedModeIndication() {
  delay(250); //Задержка 250мсек.
  (lethalMode) ? redLedOn() : greenLedOn(); //Если Боейвой режим то включить красный или же зеленый светодиод
  delay(250); //Задержка 250мсек.
  redLedOff(); //Выколючение красного светодиода
  greenLedOff(); //Выколючение зеленого светодиода
}

//Функция переключения режима ошейника и голосовое оповещение о выбранном режиме
void changeCollarMode() {
      if (buttonPressedState()) { // Если кнопка нажата
      lethalMode = !lethalMode; //Смена режима ошейника на противоположный текущему
      (lethalMode) ? voice(3) : voice(4); //Воспроизведение уведомления о выбранном режиме
    }
}

//Функция включения зеленого светодиода
void greenLedOn() {
  digitalWrite(greenLedPin, HIGH); //Подать сингал на PIN красного светодиода
}

//Функция выключения зеленого светодиода
void greenLedOff() {
  digitalWrite(greenLedPin, LOW); //Убрать сингал с PIN красного светодиода
}

//Функция включения красного светодиода
void redLedOn() {
  digitalWrite(redLedPin, HIGH); //Подать сингал на PIN красного светодиода
}

//Функция выключения красного светодиода
void redLedOff() {
  digitalWrite(redLedPin, LOW); //Убрать сингал с PIN красного светодиода
}

//Функция передачи состояния кнопки (Нажата/Отпущена)
bool buttonPressedState() {
  return(digitalRead(buttonPin) == LOW); //Вернуть true если кнопка нажата иначе false
}

//Функция передачи состояния гиркноа (Соединен/Разъединён)
bool collarOpenedState() {
  return(digitalRead(gearconPin) == HIGH);//Вернуть true если ошейник открыт иначе false
}


//Функция voice возспроизводит требуемый аудиофайл принимая его название как входящий параметр
void voice(byte track) { //Принимает параметр типа int
    p.playMp3Folder(track); //Воспроизведение аудиофайла по названию
    delay(3000); //Задежка для корректного воспроизведения аудиофайла
}

/*
Названия - соответсвующие названиям аудио файлов хранящихся на MicroSD карте:
1 - Оповещении о детонации ошейника;
2 - Оповещение об открытии замка ошейника;
3 - Оповещение о включении режима смертника;
4 - Оповещение о включении режима пленника;
5 - Инструкция с дальшейшими действиями при детонации;
6 - Инструкция с дальнейшими действиями при открытии;
7 - Оповещение об активации ошейника;
10 - Оповещение об окончении таймера через 10 минут;
20 - Оповещение об окончении таймера через 20 минут;
30 - Оповещение об окончении таймера через 30 минут;
40 - Оповещение об окончении таймера через 40 минут;
50 - Оповещение об окончении таймера через 50 минут.
*/